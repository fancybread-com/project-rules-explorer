{
  "exportedAt": "2025-11-09T19:39:44.772Z",
  "totalProjects": 1,
  "projects": [
    {
      "id": "current-workspace",
      "name": "Current Workspace",
      "path": "/Users/paul/projects/cursor/project-rules-explorer",
      "type": "current-workspace",
      "rules": [
        {
          "fileName": "performance.mdc",
          "description": "Performance optimization for VS Code extensions",
          "globs": [
            "**/*.ts",
            "**/*.js"
          ],
          "alwaysApply": false,
          "content": "# VS Code Extension Performance\n\n## Startup Performance\n\n- Use lazy loading for heavy modules\n- Minimize activation events in package.json\n- Defer expensive operations until needed\n- Use webpack bundling for production\n- Avoid synchronous operations during activation\n\n## Memory Management\n\n- Dispose of resources properly in deactivate()\n- Use weak references where appropriate\n- Implement proper caching strategies\n- Avoid memory leaks with event listeners\n- Monitor memory usage in development\n\n## File System Operations\n\n- Use async file operations exclusively\n- Implement efficient file watching\n- Cache file system queries when possible\n- Batch file operations when appropriate\n- Use streaming for large files\n\n## Tree View Performance\n\n- Implement virtual scrolling for large datasets\n- Use incremental loading for tree items\n- Cache tree item data appropriately\n- Minimize tree updates and refreshes\n- Implement efficient search and filtering\n\n## User Experience\n\n- Show progress indicators for long operations\n- Implement cancellation for user-initiated operations\n- Use debouncing for search and input handling\n- Provide immediate feedback for quick operations\n- Optimize for perceived performance"
        },
        {
          "fileName": "security.mdc",
          "description": "Security best practices for VS Code extensions",
          "globs": [
            "**/*.ts",
            "**/*.js",
            "package.json"
          ],
          "alwaysApply": true,
          "content": "# VS Code Extension Security\n\n## Input Validation\n\n- Validate all user inputs before processing\n- Sanitize file paths to prevent directory traversal\n- Check file extensions and MIME types\n- Validate JSON and YAML content before parsing\n- Use allowlists instead of blocklists for validation\n\n## File System Security\n\n- Never execute user-provided code directly\n- Validate file paths against workspace boundaries\n- Check file permissions before operations\n- Avoid writing to system directories\n- Use secure temporary file creation\n\n## Network Security\n\n- Validate URLs before making requests\n- Use HTTPS for all external communications\n- Implement proper timeout handling\n- Sanitize data received from external sources\n- Avoid storing sensitive data in plain text\n\n## Extension Manifest Security\n\n- Minimize required permissions in package.json\n- Use specific activation events\n- Avoid unnecessary workspace access\n- Review and audit all dependencies\n- Keep dependencies up to date\n\n## Data Protection\n\n- Encrypt sensitive data at rest\n- Use secure storage APIs when available\n- Implement proper session management\n- Clear sensitive data from memory\n- Follow data retention policies"
        },
        {
          "fileName": "publishing.mdc",
          "description": "VS Code extension publishing and deployment guidelines",
          "globs": [
            "package.json",
            "**/*.vsix",
            "**/*.yml",
            "**/*.yaml"
          ],
          "alwaysApply": false,
          "content": "# Extension Publishing and Deployment\n\n## Pre-Publication Checklist\n\n- Verify all commands work correctly\n- Test extension in different VS Code versions\n- Validate package.json manifest\n- Ensure proper activation events\n- Test with various workspace configurations\n\n## Package.json Requirements\n\n- Include proper display name and description\n- Set appropriate categories and keywords\n- Specify correct engine version requirements\n- Include repository and homepage URLs\n- Add proper license information\n\n## VSIX Package Creation\n\n- Use `vsce package` for production builds\n- Verify package size is reasonable\n- Test installation from VSIX file\n- Validate all files are included correctly\n- Check for unnecessary files in package\n\n## Marketplace Publishing\n\n- Use `vsce publish` for marketplace deployment\n- Increment version number appropriately\n- Write clear release notes\n- Test published extension thoroughly\n- Monitor for user feedback and issues\n\n## Version Management\n\n- Follow semantic versioning (semver)\n- Use meaningful version numbers\n- Tag releases in git repository\n- Maintain changelog for each version\n- Plan for backward compatibility"
        },
        {
          "fileName": "ui-ux.mdc",
          "description": "UI/UX guidelines for VS Code extension development",
          "globs": [
            "**/*.ts",
            "package.json"
          ],
          "alwaysApply": false,
          "content": "# VS Code Extension UI/UX Guidelines\n\n## Tree View Design\n\n- Use meaningful icons from VS Code's icon set (`vscode.ThemeIcon`)\n- Provide descriptive tooltips for tree items\n- Group related items logically (by type, directory, or function)\n- Use collapsible sections for better organization\n- Implement proper context menus with relevant actions\n\n## Command Design\n\n- Use clear, action-oriented command names\n- Provide helpful command descriptions in package.json\n- Use appropriate icons for commands\n- Group related commands in menus\n- Implement keyboard shortcuts where appropriate\n\n## User Feedback\n\n- Show progress indicators for long operations\n- Provide immediate feedback for user actions\n- Use appropriate message types (info, warning, error)\n- Implement proper loading states\n- Handle empty states gracefully with helpful messages\n\n## Accessibility\n\n- Use semantic HTML elements where applicable\n- Provide alternative text for icons\n- Ensure keyboard navigation works properly\n- Use high contrast colors when possible\n- Test with screen readers\n\n## Performance\n\n- Lazy load tree items when possible\n- Implement efficient search and filtering\n- Use virtual scrolling for large lists\n- Minimize DOM updates\n- Cache expensive computations"
        },
        {
          "fileName": "error-handling.mdc",
          "description": "Comprehensive error handling patterns for VS Code extensions",
          "globs": [
            "**/*.ts",
            "**/*.js"
          ],
          "alwaysApply": false,
          "content": "# Error Handling Best Practices\n\n## Error Handling Patterns\n\n- Always wrap async operations in try-catch blocks\n- Provide user-friendly error messages using `vscode.window.showErrorMessage()`\n- Log detailed errors to the console for debugging\n- Use specific error types when possible (e.g., `FileNotFoundError`)\n- Implement graceful degradation when operations fail\n\n## VS Code Specific Error Handling\n\n- Handle missing workspace folders gracefully\n- Check for file existence before operations\n- Validate user input before processing\n- Use `vscode.window.showWarningMessage()` for recoverable issues\n- Provide actionable error messages with suggested solutions\n\n## Resource Management\n\n- Always dispose of file watchers, event listeners, and subscriptions\n- Use `context.subscriptions.push()` for proper cleanup\n- Implement proper cancellation for long-running operations\n- Handle extension deactivation cleanly\n- Avoid memory leaks with proper resource disposal\n\n## User Experience\n\n- Show progress indicators for long operations\n- Provide clear feedback for user actions\n- Use appropriate message types (info, warning, error)\n- Implement undo functionality where possible\n- Handle network failures gracefully"
        },
        {
          "fileName": "testing.mdc",
          "description": "Testing strategies for VS Code extensions",
          "globs": [
            "**/*.test.ts",
            "**/*.spec.ts",
            "package.json"
          ],
          "alwaysApply": false,
          "content": "# VS Code Extension Testing\n\n## Unit Testing\n\n- Test individual functions and classes in isolation\n- Mock VS Code API dependencies using `@types/vscode` test utilities\n- Use Jest or Mocha for test framework\n- Aim for high code coverage on critical paths\n- Test error conditions and edge cases\n\n## Integration Testing\n\n- Test command execution end-to-end\n- Verify tree provider data loading\n- Test file system operations\n- Validate extension activation and deactivation\n- Test workspace folder changes\n\n## VS Code Extension Testing\n\n- Use `@vscode/test-electron` for extension testing\n- Test in different VS Code versions\n- Verify extension works in different workspace configurations\n- Test with various file types and project structures\n- Validate extension marketplace compatibility\n\n## Test Data Management\n\n- Use fixtures for consistent test data\n- Create temporary workspaces for testing\n- Clean up test artifacts after tests\n- Use meaningful test descriptions\n- Group related tests logically\n\n## Continuous Integration\n\n- Run tests on multiple Node.js versions\n- Test on different operating systems\n- Validate package.json and extension manifest\n- Check for security vulnerabilities\n- Ensure proper TypeScript compilation"
        },
        {
          "fileName": "typescript-extension.mdc",
          "description": "TypeScript VS Code extension development best practices",
          "globs": [
            "**/*.ts",
            "**/*.js",
            "package.json",
            "tsconfig.json"
          ],
          "alwaysApply": true,
          "content": "# TypeScript VS Code Extension Development\n\n## Code Quality Standards\n\n- Use strict TypeScript configuration with `strict: true`\n- Prefer `const` over `let`, avoid `var` entirely\n- Use explicit return types for public methods\n- Implement proper error handling with try-catch blocks\n- Use async/await over Promise chains for better readability\n\n## VS Code API Usage\n\n- Always dispose of resources in the `deactivate()` function\n- Use `vscode.workspace.fs` for file operations instead of Node.js fs\n- Register commands and providers in the `activate()` function\n- Use proper activation events in package.json to optimize startup time\n- Implement proper tree data providers with refresh capabilities\n\n## Extension Architecture\n\n- Separate concerns: scanners, providers, commands, and utilities\n- Use dependency injection where appropriate\n- Implement proper file watching for auto-refresh functionality\n- Handle workspace folder changes gracefully\n- Provide meaningful error messages to users\n\n## Performance Considerations\n\n- Lazy load heavy operations\n- Use file system watchers efficiently\n- Implement proper caching for expensive operations\n- Avoid blocking the main thread with synchronous operations\n- Use webpack or similar bundling for production builds"
        },
        {
          "fileName": "documentation.mdc",
          "description": "Documentation standards for VS Code extensions",
          "globs": [
            "**/*.md",
            "**/*.ts",
            "package.json"
          ],
          "alwaysApply": false,
          "content": "# Documentation Standards\n\n## Code Documentation\n\n- Use JSDoc comments for all public APIs\n- Include parameter types and return types\n- Provide usage examples in comments\n- Document complex algorithms and business logic\n- Keep comments up to date with code changes\n\n## README Documentation\n\n- Include clear installation instructions\n- Provide usage examples with screenshots\n- Document all available commands and features\n- Include troubleshooting section\n- Keep changelog up to date\n\n## API Documentation\n\n- Document all extension commands\n- Explain tree view structure and items\n- Provide configuration options documentation\n- Include extension manifest documentation\n- Document activation events and conditions\n\n## User Documentation\n\n- Write clear, concise user instructions\n- Use consistent terminology throughout\n- Include keyboard shortcuts and commands\n- Provide step-by-step tutorials\n- Include FAQ section for common issues\n\n## Developer Documentation\n\n- Document build and development setup\n- Explain extension architecture and design decisions\n- Provide contribution guidelines\n- Include testing instructions\n- Document deployment and publishing process"
        },
        {
          "fileName": "project-specific.mdc",
          "description": "Specific rules for the Project Rules Explorer extension",
          "globs": [
            "**/*.ts",
            "**/*.js",
            "package.json"
          ],
          "alwaysApply": true,
          "content": "# Project Rules Explorer Specific Guidelines\n\n## MDC File Handling\n\n- Support both .mdc and .md file extensions\n- Parse YAML frontmatter using gray-matter library\n- Validate MDC structure and required fields\n- Handle parsing errors gracefully\n- Support file references (e.g., @service-template.ts)\n\n## Tree View Structure\n\n- Group rules by directory structure\n- Show rule type with appropriate icons\n- Display rule metadata in tooltips\n- Implement proper context menus\n- Support both Rules and State sections\n\n## File System Operations\n\n- Watch for changes in .cursor/rules directories\n- Support recursive directory scanning\n- Handle file creation, modification, and deletion\n- Implement proper error handling for file operations\n- Use VS Code's file system API exclusively\n\n## State Detection\n\n- Detect frameworks from package.json and other config files\n- Identify architecture patterns from directory structure\n- Find configuration files and key project files\n- Provide comprehensive project analysis\n- Export state data in JSON format\n\n## User Experience\n\n- Provide immediate feedback for all operations\n- Show progress indicators for long operations\n- Implement proper error messages and warnings\n- Support rule creation with guided wizard\n- Enable rule editing and deletion with confirmation"
        }
      ],
      "state": {
        "languages": [
          "JavaScript/TypeScript"
        ],
        "frameworks": [
          "Node.js"
        ],
        "dependencies": [
          "yaml (^2.3.0)",
          "gray-matter (^4.0.3)",
          "@vscode/test-electron (^2.3.0)",
          "mocha (^10.0.0)",
          "typescript (^5.4.0)",
          "@types/vscode (^1.74.0)",
          "@typescript-eslint/eslint-plugin (^6.0.0)",
          "@typescript-eslint/parser (^6.0.0)",
          "eslint (^8.0.0)"
        ],
        "buildTools": [
          "github-actions (cd)",
          "github-actions (ci)",
          "github-actions (dependabot)",
          "github-actions (main-branch)",
          "TypeScript Compiler"
        ],
        "testing": [
          "Mocha",
          "Test directory structure"
        ],
        "codeQuality": [
          "ESLint",
          "TypeScript"
        ],
        "developmentTools": [
          "npm",
          "Git",
          "Git ignore configured"
        ],
        "architecture": [
          "VS Code extension architecture (providers + commands)",
          "src/ structure with 6 subdirectories (commands, providers, scanner, services, types...)",
          "Service layer (business logic encapsulation)",
          "Utility functions (helper/shared functions)"
        ],
        "configuration": [
          ".gitignore",
          ".github/workflows"
        ],
        "documentation": [
          "README.md",
          "CHANGELOG.md",
          "LICENSE"
        ],
        "security": {
          "authFrameworks": [],
          "encryption": [],
          "vulnerabilityScanning": [
            "Dependabot"
          ],
          "secretsManagement": []
        },
        "projectMetrics": {
          "estimatedSize": "medium",
          "complexity": "medium",
          "filesAnalyzed": 137,
          "lastAnalyzed": "2025-11-09T19:39:44.885Z"
        },
        "identity": {
          "projectType": "vscode-extension",
          "domain": "general",
          "primaryLanguage": "TypeScript",
          "maturityLevel": "active-development"
        },
        "capabilities": {
          "description": "Visualize and manage Cursor project rules and state with enhanced detection",
          "primaryFeatures": [
            "Rules Visualization: Tree view of all .cursor/rules directories",
            "Rule Viewer: Markdown preview with syntax highlighting",
            "Rule Editor: Create/edit rules with template scaffolding",
            "Auto-refresh: Watch file system for changes",
            "Rule Management: Visual indicators and management tools for rules"
          ],
          "dataFormats": [
            "JSON",
            "YAML",
            "MDC"
          ]
        },
        "enhancedArchitecture": {
          "style": "layered",
          "organization": "service-oriented",
          "patterns": [
            "Provider Pattern (data/service providers)",
            "Command Pattern (encapsulated operations with multiple command handlers)",
            "Service Layer Pattern (business logic encapsulation)"
          ],
          "entryPoints": [
            "src/extension.ts"
          ]
        },
        "enhancedDependencies": {
          "byPurpose": {
            "parsing": [
              {
                "name": "yaml",
                "version": "^2.3.0",
                "purpose": "Parse/stringify YAML",
                "critical": true
              },
              {
                "name": "gray-matter",
                "version": "^4.0.3",
                "purpose": "Parse YAML frontmatter",
                "critical": true
              }
            ],
            "testing": [
              {
                "name": "@vscode/test-electron",
                "version": "^2.3.0",
                "purpose": "VS Code extension testing",
                "critical": false
              },
              {
                "name": "mocha",
                "version": "^10.0.0",
                "purpose": "Test runner",
                "critical": false
              }
            ],
            "build": [
              {
                "name": "typescript",
                "version": "^5.4.0",
                "purpose": "Type checking and compilation",
                "critical": true
              }
            ],
            "platform": [
              {
                "name": "@types/vscode",
                "version": "^1.74.0",
                "purpose": "VS Code API types",
                "critical": true
              }
            ],
            "code-quality": [
              {
                "name": "@typescript-eslint/eslint-plugin",
                "version": "^6.0.0",
                "purpose": "TypeScript ESLint rules",
                "critical": false
              },
              {
                "name": "@typescript-eslint/parser",
                "version": "^6.0.0",
                "purpose": "TypeScript ESLint parser",
                "critical": false
              },
              {
                "name": "eslint",
                "version": "^8.0.0",
                "purpose": "Code linting",
                "critical": false
              }
            ],
            "utility": [],
            "http": [],
            "framework": []
          },
          "criticalPath": [
            "yaml",
            "gray-matter"
          ],
          "devOnly": [
            "@types/mocha",
            "@types/node",
            "@types/vscode",
            "@typescript-eslint/eslint-plugin",
            "@typescript-eslint/parser",
            "@vscode/test-electron",
            "eslint",
            "glob",
            "mocha",
            "nyc",
            "ts-node",
            "typescript"
          ]
        },
        "platformContext": {
          "vscode": {
            "extensionType": "productivity",
            "category": "Other",
            "minVersion": "^1.74.0",
            "activation": [
              "onView:projectRulesExplorer",
              "onCommand:projectRules.addProject",
              "onCommand:projectRules.refresh",
              "onCommand:projectRules.listProjects",
              "onCommand:projectRules.exportForAgent"
            ],
            "contributes": {
              "commands": 18,
              "views": 1,
              "configuration": false,
              "menus": true,
              "languages": 0,
              "themes": 0
            },
            "capabilities": [
              "Provides custom commands",
              "Adds custom views to sidebar",
              "Adds custom view containers",
              "Context menus"
            ]
          }
        },
        "agentGuidance": {
          "suggestedApproach": "This is a VS Code extension. Modifications should maintain VS Code API compatibility, properly dispose resources, and follow extension development best practices. Use vscode.workspace.fs for file operations and register all disposables.",
          "criticalFiles": [
            "package.json",
            "src/extension.ts",
            "src/extension.ts",
            "src/providers/**/*.ts",
            "package.json (contributes section)",
            "test/**/*.test.ts"
          ],
          "commonTasks": [
            "Adding new commands",
            "Enhancing tree view functionality",
            "Adding configuration options",
            "Implementing context menus",
            "Writing tests",
            "Enhancing existing features"
          ],
          "watchOuts": [
            "Dispose resources properly in deactivate()",
            "Use vscode.workspace.fs for file operations",
            "Test with various workspace configurations",
            "Register all commands in package.json",
            "Avoid blocking the main thread",
            "Critical dependencies: yaml, gray-matter - changes may break core functionality",
            "Be cautious with workspace.fs.readFile - validate paths to prevent directory traversal",
            "Sanitize user inputs before displaying in UI"
          ]
        }
      }
    }
  ]
}